/*
 * This Kotlin source file was generated by the Gradle 'init' task.
 */
package server

import io.netty.channel.EventLoopGroup
import io.netty.channel.nio.NioEventLoop
import io.netty.channel.nio.NioEventLoopGroup
import io.netty.bootstrap.ServerBootstrap
import io.netty.channel.socket.nio.NioServerSocketChannel
import io.netty.channel.socket.SocketChannel
import io.netty.channel.ChannelInitializer
import io.netty.channel.ChannelPipeline
import io.netty.channel.ChannelOption
import java.net.InetSocketAddress
import io.netty.channel.ChannelFuture
import io.netty.handler.logging.LoggingHandler
import io.netty.handler.logging.LogLevel
import io.netty.handler.codec.http.HttpServerCodec
import io.netty.handler.codec.http.HttpObjectAggregator
import io.netty.handler.codec.http.websocketx.WebSocketServerProtocolHandler
import io.netty.handler.stream.ChunkedWriteHandler
import server.OnMessagehandler



val WebSocketChannelInitializer = object: ChannelInitializer<SocketChannel>() {
    override fun initChannel(socketChannel: SocketChannel)  {
        val pipeline: ChannelPipeline = socketChannel.pipeline();

        //websocket协议本身是基于http协议的，所以这边也要使用http解编码器
        pipeline.addLast(HttpServerCodec());
        //以块的方式来写的处理器
        pipeline.addLast(ChunkedWriteHandler());
        //netty是基于分段请求的，HttpObjectAggregator的作用是将请求分段再聚合,参数是聚合字节的最大长度
        pipeline.addLast(HttpObjectAggregator(1024*1024*1024));

        //ws://server:port/context_path
        //ws://localhost:9999/ws
        //参数指的是contex_path
        pipeline.addLast(WebSocketServerProtocolHandler("/ws",null,true,65535));

        //websocket定义了传递数据的6中frame类型
        pipeline.addLast(OnMessagehandler());
    }
}


fun runNettyWebsocketServer() {
    val bossGroup: EventLoopGroup = NioEventLoopGroup()
    val wokerGroup: EventLoopGroup =  NioEventLoopGroup()
    try{
        val serverBootstrap: ServerBootstrap =  ServerBootstrap()
        serverBootstrap.group(bossGroup,wokerGroup).channel(NioServerSocketChannel::class.java)
                .handler( LoggingHandler(LogLevel.INFO))
                .option(ChannelOption.SO_KEEPALIVE,true)
                .option(ChannelOption.SO_BACKLOG,1024*1024*10)
                .childHandler(WebSocketChannelInitializer)

         val channelFuture: ChannelFuture = serverBootstrap.bind( InetSocketAddress(8899)).sync()
        channelFuture.channel().closeFuture().sync()
    }finally {
        bossGroup.shutdownGracefully()
        wokerGroup.shutdownGracefully()
    }
}

fun main(args: Array<String>) {
    runNettyWebsocketServer()
}
